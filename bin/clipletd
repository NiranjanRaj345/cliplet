#!/usr/bin/env python3
"""
Cliplet - Clipboard Manager Daemon

This is the main executable for the Cliplet daemon.
It provides proper argument parsing, logging setup, and daemon management.
"""

import sys
import os
import signal
import argparse
import logging
from pathlib import Path

# Add the absolute source directory to Python path for module resolution
src_path = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', 'src'))
if src_path not in sys.path:
    sys.path.insert(0, src_path)

try:
    from cliplet.config import ConfigManager, get_log_file, get_pid_file
    from cliplet.core.daemon import ClipboardDaemon
    from cliplet.utils.logging import setup_logging
    from cliplet.utils.pid import PidManager
except ImportError as e:
    print(f"Error: Failed to import Cliplet modules: {e}", file=sys.stderr)
    print("Please ensure the application is properly installed.", file=sys.stderr)
    sys.exit(1)

def setup_signal_handlers(daemon):
    """Setup signal handlers for graceful shutdown"""
    def signal_handler(signum, frame):
        logging.info(f"Received signal {signum}, shutting down gracefully...")
        daemon.stop()
        sys.exit(0)
    
    signal.signal(signal.SIGTERM, signal_handler)
    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGHUP, lambda s, f: daemon.reload_config())

def main():
    """Main entry point for the daemon"""
    parser = argparse.ArgumentParser(
        description="Cliplet - Clipboard Manager Daemon",
        prog="clipletd"
    )
    
    parser.add_argument(
        '--config', '-c',
        type=Path,
        help="Path to configuration file"
    )
    
    parser.add_argument(
        '--log-level', '-l',
        choices=['DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL'],
        default='INFO',
        help="Set logging level"
    )
    
    parser.add_argument(
        '--log-file',
        type=Path,
        help="Path to log file (default: uses XDG directories)"
    )
    
    parser.add_argument(
        '--foreground', '-f',
        action='store_true',
        help="Run in foreground (don't daemonize)"
    )
    
    parser.add_argument(
        '--pid-file', '-p',
        type=Path,
        help="Path to PID file"
    )
    
    parser.add_argument(
        '--version', '-v',
        action='version',
        version='%(prog)s 1.0.1'
    )
    
    parser.add_argument(
        '--check-config',
        action='store_true',
        help="Validate configuration and exit"
    )
    
    args = parser.parse_args()
    
    # Setup logging
    log_file = args.log_file or get_log_file()
    setup_logging(
        level=args.log_level,
        log_file=log_file,
        console=args.foreground
    )
    
    logger = logging.getLogger(__name__)
    logger.info("Starting Cliplet v1.0.1")
    
    try:
        # Load configuration
        config = ConfigManager(args.config)
        
        if args.check_config:
            if config.validate():
                print("Configuration is valid")
                sys.exit(0)
            else:
                print("Configuration validation failed")
                sys.exit(1)
        
        # Setup PID file management
        pid_file = args.pid_file or get_pid_file()
        pid_manager = PidManager(pid_file)
        
        if not args.foreground:
            # Check if already running
            if pid_manager.is_running():
                print(f"Daemon is already running (PID: {pid_manager.get_pid()})")
                sys.exit(1)
            
            # Create PID file
            pid_manager.create()
        
        # Create and start daemon
        daemon = ClipboardDaemon(config)
        
        # Setup signal handlers
        setup_signal_handlers(daemon)
        
        if not args.foreground:
            logger.info(f"Daemon started with PID: {os.getpid()}")
        
        # Start the daemon
        daemon.run()
        
    except KeyboardInterrupt:
        logger.info("Received interrupt signal, shutting down...")
    except Exception as e:
        logger.error(f"Fatal error: {e}", exc_info=True)
        sys.exit(1)
    finally:
        # Cleanup PID file
        if not args.foreground:
            try:
                pid_manager.remove()
            except:
                pass

if __name__ == "__main__":
    main()